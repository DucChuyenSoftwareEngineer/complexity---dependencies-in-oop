# Complexity-dependencies-in-oop

What is Dependency
 
 In fact, in object-oriented programming all this can be summarized by classes depending on other classes. Whenever class A uses another class B, then it is said that A depends on B. A can not work without B, and A can not be reused without also reusing B. In such a situtation, the class A is called a dependent, and the class B is called a dependency.

1. Class dependencies

![A-depends-B](https://user-images.githubusercontent.com/59278166/182037050-148bfe2e-5d88-4873-bc77-af0869af6a48.png)

These classes are coupled either strongly or loosely, but let’s see a concrete example.
![cdi-example](https://user-images.githubusercontent.com/59278166/182037252-c70afdb9-8372-4bf6-9f25-4d3d1eca7468.png)

Here we have a class, BookService, whose job is to create books. A book is represented by a book class that contains the title of the book and a number. This number is actually an ISBN number generated by an IsbnGenerator class, which has a method called generateNumber().

In the above diagram, BookService depends on an IsbnGenerator to create a book. Without an ISBN, the book could not be created. This dependency between classes is typical in object-oriented design. Classes have separate concerns.

Strongly coupled dependencies

Two classes that use each other are called coupled. Decoupling between classes can be loose or tight. Tight coupling leads to strong dependencies between classes. In an above example, IsbnGenerator is a class that has a unique method, generateNumber(), that returns an ISBN as a string. The simplicity will develop a very simple algorithm that generates a random number, starting by 13.

![image](https://user-images.githubusercontent.com/59278166/182037639-05a6c15b-30e3-4cee-8e27-f100d8667e6a.png)

On the other hand, the BookService class is in charge of creating a book object. The createBook() method takes a title as a parameter and returns a Book object.

![image](https://user-images.githubusercontent.com/59278166/182037692-ba2a42b9-0dbb-4329-8d6a-25a6687ad6f0.png)

To complete, the Book object needs the title, as well as an ISBN number, and for that it delegates the work to the IsbnGenerator class. As we can see, there is a strong dependency between those two classes. The BookService class depends on the IsbnGenerator class, but what’s wrong with that?

This type of depdency on the IsbnGenerator class means that BookService is only capable of creating books with ISBN numbers. It cannot use any other number generator, if needed. We can say that BookService is tightly coupled to the IsbnGenerator class and thereby the number generator algorithm. It shows the strong coupling between classes can be bad because it decreases reuse. Remember that in OOP code, reuse is the idea that a class written at one time can be used by another class written at a later time.

Strong coupling reduces reusability and, therefore, development speed, code quality, code readability, and so forth.

2, Loosely coupled Dependencies

A less tightly couplied solution would help in changing the NumberGenerator implementation at runtime. A way of doing it is through interfaces. Instead of depdending on the IsbnGenerator class, the BookService could depend on a NumberGenerator interface. This interface has one method called generateNumber() and is implemented by IsbnGenerator. If we need to generate ISSN numbers, we just create a new class called IssnGenerator that implements a different NumberGenerator algorithm. The BookService ends up depending on either an IsbnGenerator or an IssnGenerator according to some conditions or environment.
![cdi-example-loose-coupling](https://user-images.githubusercontent.com/59278166/182037829-8a9f6959-8243-4b90-b496-ae08110a6956.png)

In terms of code, it’s quite easy. Everything starts with a Number Generator interface that defines a generateNumber() method. This interface is implemented by the IsbnGenerator, which defines its own NumberGenerator algorithm, here a random number with a prefix starting with 13. To have a different implementation, we create a new class that implements a same NumberGenerator interface and redefines a different NumberGenerator algorithm, this time a number starting with 8.
![image](https://user-images.githubusercontent.com/59278166/182037884-68c032f5-5391-49e8-8c86-141486e77c77.png)

Now that the classes are not directly coupled, how would we connect a BookService to either an ISBN or ISSN implementation? One solution is to pass the implementation to the constructor and leave an external class to choose which implementation is wants to use. So let’s refactor our BookService.

![image](https://user-images.githubusercontent.com/59278166/182037935-ac25280b-0544-4b3c-b8cd-0e5e45ecbe72.png)

The BookService depends on an interface, not implementation. The implementation is passed as parameter of the constructor. So if we need a BookService that generates an ISBN number, we just pass the IsbnGenerator implementation to the constructor. If we need to generate an ISSN number, we just change the implementation to be IssnGenerator. This is what’s called Inversion of Control. The control of choosing the dependency is inverted because it’s giving to an external class, not the class itself. But we ends up connecting the dependencies ourselves using the constructor to choose implementation. This is called Constructor injection. Our techniques can be used, but all-in-all is just constructing dependency programmatically by hand, which is not flexible. Instead of constructing depedencies by hand, we can leave an injector to do it by using some frameworks such as CDI of Java EE, Dependency Injection of Spring framework, or something else.

